import torch

import numpy as np

from skimage.exposure import rescale_intensity

# put pytorch-style transforms here


def normalize_target(
    target_value: float,
    input_min: float,
    input_max: float,
    output_min: float = -1.0,
    output_max: float = 1.0,
) -> float:
    """
    converts a target value with known range to equivalent value in
    [-1, 1]

    Parameters
    ----------
    target : float
        value to be mapped into [-1, 1]
    input_min : float
        the minimum possible value for items generated by this target
    input_max : float
        the maximum possible value for items generated by this target
    output_min : float, optional
        minimum value in the new output range, by default -1.0
    output_max : float, optional
        maximum value in the new output range, by default 1.0

    Returns
    -------
    float
        `target_value` mapped into the range [target_min, target_max]
    """
    old_range = input_max - input_min
    target_range = output_max - output_min
    return (((target_value - input_min) * target_range) / old_range) + output_min


def denormalize_target(
    normalized_target: float,
    output_min: float,
    output_max: float,
    input_min: float = -1.0,
    input_max: float = 1.0,
) -> float:
    """
    converts a normalized target to the equivalent value in
    [output_min, output_max]

    Parameters
    ----------
    normalized_target : float
        a normalized target value, contained in [input_min, input_max]
    output_min : float
        the minimum possible value for items associated with a specific target
    output_max : float
        the maximum possible value for items associated with a specific target
    input_min : float, optional
        minimum value in the normalized input range, by default -1.0
    input_max : float, optional
        maximum value in the normalized input range, by default 1.0

    Returns
    -------
    float
        `normalized_target` mapped into the range [output_min, output_max]
    """
    old_range = input_max - input_min
    target_range = output_max - output_min
    return (((normalized_target - input_min) * target_range) / old_range) + output_min


class NormalizeTarget:
    """abstracts normalizing and denormalizing target values and target predictions,
    respectively"""

    def __init__(self, target_column_ind: int):
        """
        initializes `NormalizeTarget`

        Parameters
        ----------
        target_column_ind : int
            column index where values from a specific target can be found
        """
        self.target_column_ind = target_column_ind
        self.target_minimum = None
        self.target_maximum = None
        self.normalizer = None
        self.denormalizer = None

    def __call__(self, sample: dict) -> dict:
        """
        maps target values found in `sample['pred_metric']` to the range [-1, 1]

        Parameters
        ----------
        sample : dict
            generated by a dataset in `wawenet_trainer.lightning_data`, must contain
            a field named `pred_metric`, which maps to an np.ndarray that contains
            measurements associated with a specific speech sample in the rows of
            the array while the columns represent targets

        Returns
        -------
        dict
            the same format as `sample`, but target values for the target
            associated with this normalizer have been remapped
        """
        sample["pred_metric"][self.target_column_ind] = self.normalizer(
            sample["pred_metric"][self.target_column_ind],
            self.target_minimum,
            self.target_maximum,
        )
        return sample

    def norm(self, column_vec: np.ndarray) -> np.ndarray:
        """
        accepts a column vector of un-normalized data, returns a column
        vector of normalized data

        Parameters
        ----------
        column_vec : np.ndarray
            a column vector of denormalized target data

        Returns
        -------
        np.ndarray
            a column vector of normalized target data
        """
        return self.normalizer(column_vec, self.target_minimum, self.target_maximum)

    def denorm(self, column_vec: np.ndarray) -> np.ndarray:
        """
        accepts a column vector of normalized data, returns a column
        vector of denormalized data

        Parameters
        ----------
        column_vec : np.ndarray
            a column vector of normalized target data

        Returns
        -------
        np.ndarray
            a column vector of denormalized target data
        """
        return self.denormalizer(column_vec, self.target_minimum, self.target_maximum)


class NormalizeGenericTarget(NormalizeTarget):
    """normalize target values to the range (-1, 1) using an affine transform"""

    MIN = 1
    "the minimum value associated with this target"
    MAX = 5
    "the maximum value associated with this target"
    name = "¯\\_(ツ)_/¯"
    "name of this target"
    tick_start_stop_step = (1, 6, 1)
    "matplotlib tick start, stop, and step, used for plotting"

    def __init__(self, target_column_ind=0):
        super().__init__(target_column_ind)
        self.normalizer = normalize_target
        self.denormalizer = denormalize_target
        self.target_minimum = self.MIN
        self.target_maximum = self.MAX


class NormalizeMos(NormalizeGenericTarget):
    """normalize NISQA MOS values to the range (-1, 1)."""

    name = "MOS"


class NormalizeNoi(NormalizeGenericTarget):
    """normalize NISQA noise values to the range (-1, 1)."""

    name = "NOI"


class NormalizeCol(NormalizeGenericTarget):
    """normalize NISQA color values to the range (-1, 1)."""

    name = "COL"


class NormalizeDis(NormalizeGenericTarget):
    """normalize NISQA discontinuity values to the range (-1, 1)."""

    name = "DIS"


class NormalizeLoud(NormalizeGenericTarget):
    """normalize NISQA loudness values to the range (-1, 1)."""

    name = "LOUD"


class NormalizePESQMOSLQO(NormalizeGenericTarget):
    """normalize PESQMOSLQO values to the range (-1, 1)."""

    name = "PESQMOSLQO"
    MIN = 1.01
    MAX = 4.64


class NormalizePOLQAMOSLQO(NormalizeGenericTarget):
    """normalize POLQAMOSLQO values to the range (-1, 1)."""

    name = "POLQAMOSLQO"
    MIN = 1
    MAX = 4.75


class NormalizePEMO(NormalizeGenericTarget):
    """normalize PEMO values to the range (-1, 1)."""

    name = "PEMO"
    MIN = 0
    MAX = 1
    tick_start_stop_step = (0, 1.1, 0.2)


class NormalizeViSQOL3_c310(NormalizeGenericTarget):
    """normalize ViSQOL3_c310 values to the range (-1, 1)."""

    name = "ViSQOL3_c310"
    MIN = 1
    MAX = 5


class NormalizeSTOI(NormalizeGenericTarget):
    """normalize STOI values to the range (-1, 1)."""

    name = "STOI"
    MIN = 0.45
    MAX = 1
    tick_start_stop_step = (0, 1.1, 0.2)


class NormalizeESTOI(NormalizeGenericTarget):
    """normalize ESTOI values to the range (-1, 1)."""

    name = "ESTOI"
    MIN = 0.23
    MAX = 1
    tick_start_stop_step = (0, 1.1, 0.2)


class NormalizeSIIBGauss(NormalizeGenericTarget):
    """normalize SIIBGauss values to the range (-1, 1)."""

    name = "SIIBGauss"
    MIN = 0
    MAX = 750


class NormalizeIUScaledMOS(NormalizeGenericTarget):
    """normalize IU-style MOS to the range ()"""

    name = "scaled_mos"
    MIN = 0
    MAX = 10
    tick_start_stop_step = (1, 11, 1)


class NormalizeIUMOS(NormalizeGenericTarget):
    """normalize IU-style MOS to the range ()"""

    name = "mos"
    MIN = 0
    MAX = 100


class RightPadSampleTensor:
    """zero-pad a speech segment to a specified length in samples"""

    def __init__(self, final_length: int):
        """
        initializes RightPadhSampleTensor

        Parameters
        ----------
        final_length : int
            the number of samples that should be present in the padded speech
            segment
        """
        self.final_length = final_length

    def __call__(self, sample: dict) -> dict:
        """
        pads a speech segment to `self.final_sength` samples

        Parameters
        ----------
        sample : dict
            generated by a dataset in `wawenet_trainer.lightning_data`, must contain
            a field named `sample_data`, which maps to an np.ndarray containing speech data

        Returns
        -------
        dict
            same format as `sample`, but the np.ndarray found in `sample_data` will now
            have `self.final_length` samples
        """
        # calculate how much to pad
        num_channels, num_samples = sample["sample_data"].shape
        pad_length = self.final_length - num_samples
        if pad_length == 0:
            return sample
        elif pad_length < 0:
            sample["sample_data"] = sample["sample_data"][:, : self.final_length]
            return sample
        padder = torch.nn.ConstantPad1d((0, pad_length), 0)
        sample["sample_data"] = padder(sample["sample_data"])
        return sample


class AudioToTensor:
    """Convert ndarrays in sample to Tensors."""

    def __call__(self, sample: dict) -> dict:
        """
        converts numeric data in `sample` from np.ndarray to tensor

        Parameters
        ----------
        sample : dict
            generated by a dataset in `wawenet_trainer.lightning_data`, must contain
            fields named `sample_data` and `pred_metric` which map to speech data
            and target values associated with `sampledata`, respectively

        Returns
        -------
        dict
            same format as `sample`, but numeric data will be pytorch tensors
        """
        sample.update(
            {
                "sample_data": torch.from_numpy(sample["sample_data"]),
                "pred_metric": torch.from_numpy(sample["pred_metric"]),
            }
        )
        return sample


class NormalizeAudio:
    """Normalize numpy audio arrays to the range (-1, 1)."""

    def __call__(self, sample: dict) -> dict:
        """
        normalizes speech data for processing by a WAWEnet.

        Parameters
        ----------
        sample : dict
            generated by a dataset in `wawenet_trainer.lightning_data`, must contain
            a field named `sample_data` which maps to speech data

        Returns
        -------
        dict
            the same format as `sample` but the speech data found in `sample_data` will
            be in the range (-1, 1)
        """
        sample["sample_data"] = rescale_intensity(
            sample["sample_data"],
            in_range=(-(2**15) + 1, 2**15 - 1),
            out_range=(-1, 1),
        )
        return sample


class InvertAudioPhase:
    """Invert the phase of an audio vector for data augmentation purposes."""

    def __call__(self, sample: dict) -> dict:
        """
        inverts the phase of an audio sample

        Parameters
        ----------
        sample : dict
            generated by a dataset in `wawenet_trainer.lightning_data`, must contain
            a field named `sample_data`, which maps to speech data

        Returns
        -------
        dict
            the same format as `sample` but the phase of the speech data found in
            `sample_data` will be inverted.
        """
        sample["sample_data"] = sample["sample_data"] * -1
        return sample


def get_normalizer_class(
    target: str, target_column_ind: int = 0
) -> NormalizeGenericTarget:
    """
    returns an appropriately-configured normalizer class given `target` and
    `target_column_ind`

    Parameters
    ----------
    target : str
        specific name for a target. these names are what is used to access
        target values in WAWEnet datasets.
    target_column_ind : int, optional
        the column index where measurements generated by this specific target
        will reside, by default 0

    Returns
    -------
    NormalizeGenericTarget
        a correctly-configured normalizer for the given combination of `target`
        and `target_column_ind`
    """
    # `target_column_ind` is what selects the proper target value when there are multiple
    # targets
    # TODO: is this the right place to put this dict?
    normalizer_map = {
        "mos": NormalizeMos,
        "noi": NormalizeNoi,
        "col": NormalizeCol,
        "dis": NormalizeDis,
        "loud": NormalizeLoud,
        "PESQMOSLQO": NormalizePESQMOSLQO,
        "POLQAMOSLQO": NormalizePOLQAMOSLQO,
        "PEMO": NormalizePEMO,
        "ViSQOL3_c310": NormalizeViSQOL3_c310,
        "STOI": NormalizeSTOI,
        "ESTOI": NormalizeESTOI,
        "SIIBGauss": NormalizeSIIBGauss,
        "IUScaledMOS": NormalizeIUScaledMOS,
        "IUMOS": NormalizeIUMOS,
    }
    instance = normalizer_map[target](target_column_ind=target_column_ind)
    return instance
